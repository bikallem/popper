{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Popper is an OCaml testing library that can be used for writing simple unit-tests as well as property-based ones. Its underlying design is inspired by the Python library Hypothesis . Warning Popper is currently in alpha-stage and is to be used at your own risk. High-level features of Popper include: A uniform API for defining regular unit and property-based tests. Embedded shrinking \u2014 invariants that were used when constructing samples for property-based tests are always respected. Compositional design \u2014 tests may be bundled and nested arbitrarily. Ships with a ppx for automatically deriving comparator and sample functions for custom data types. Deterministic (and reproducible) results. Colorful output (cred goes to Alcotest , couldn't resist the inspiration). Support for line-number reporting, timing information and logging. Learn Check out the getting started section for a step by step introduction. Take a look at some examples . Browse the API . View the source repository . Show me an example Here's what test output looks like: It was generated from the following code: open Popper open Sample.Syntax type exp = | Lit of bool | And of exp * exp | Or of exp * exp | Not of exp [@@deriving show, ord, popper] (* A buggy evaluator function *) let rec eval = function | Lit b -> b | And (e1, e2) -> eval e1 || eval e2 | Or (e1, e2) -> eval e1 || eval e2 | Not b -> not @@ eval b (* A simple unit test *) let test_hello_world = test @@ fun () -> equal Comparator.string \"hello world\" (String.lowercase_ascii \"Hello World\") (* Another unit test *) let test_lit_true = test @@ fun () -> is_true (eval (Lit true) = true) (* A property-based test *) let test_false_ident_or = test @@ fun () -> let* e = exp_sample in is_true (eval e = eval (Or (Lit false, e))) (* Another property-based test *) let test_true_ident_and = test @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true ~loc:__LOC__ (eval e = eval (And (Lit true, e))) let suite = suite [ (\"Hello World\", test_hello_world) ; (\"Lit true\", test_lit_true) ; (\"False ident or\", test_false_ident_or) ; (\"True ident and\", test_true_ident_and) ] let () = run suite","title":"About"},{"location":"#about","text":"Popper is an OCaml testing library that can be used for writing simple unit-tests as well as property-based ones. Its underlying design is inspired by the Python library Hypothesis . Warning Popper is currently in alpha-stage and is to be used at your own risk. High-level features of Popper include: A uniform API for defining regular unit and property-based tests. Embedded shrinking \u2014 invariants that were used when constructing samples for property-based tests are always respected. Compositional design \u2014 tests may be bundled and nested arbitrarily. Ships with a ppx for automatically deriving comparator and sample functions for custom data types. Deterministic (and reproducible) results. Colorful output (cred goes to Alcotest , couldn't resist the inspiration). Support for line-number reporting, timing information and logging.","title":"About"},{"location":"#learn","text":"Check out the getting started section for a step by step introduction. Take a look at some examples . Browse the API . View the source repository .","title":"Learn"},{"location":"#show-me-an-example","text":"Here's what test output looks like: It was generated from the following code: open Popper open Sample.Syntax type exp = | Lit of bool | And of exp * exp | Or of exp * exp | Not of exp [@@deriving show, ord, popper] (* A buggy evaluator function *) let rec eval = function | Lit b -> b | And (e1, e2) -> eval e1 || eval e2 | Or (e1, e2) -> eval e1 || eval e2 | Not b -> not @@ eval b (* A simple unit test *) let test_hello_world = test @@ fun () -> equal Comparator.string \"hello world\" (String.lowercase_ascii \"Hello World\") (* Another unit test *) let test_lit_true = test @@ fun () -> is_true (eval (Lit true) = true) (* A property-based test *) let test_false_ident_or = test @@ fun () -> let* e = exp_sample in is_true (eval e = eval (Or (Lit false, e))) (* Another property-based test *) let test_true_ident_and = test @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true ~loc:__LOC__ (eval e = eval (And (Lit true, e))) let suite = suite [ (\"Hello World\", test_hello_world) ; (\"Lit true\", test_lit_true) ; (\"False ident or\", test_false_ident_or) ; (\"True ident and\", test_true_ident_and) ] let () = run suite","title":"Show me an example"},{"location":"api_documentation/","text":"API documentation See API documentation here .","title":"API documentation"},{"location":"api_documentation/#api-documentation","text":"See API documentation here .","title":"API documentation"},{"location":"getting_started/","text":"Getting started In the following sections we'll look at how to get started using Popper for writing and running tests. Popper consists of two parts: A library popper \u2014 containing functions for building and executing tests. A library ppx_deriving_popper \u2014 for deriving functions for sampling and comparing test data for custom data-types. Installation Installing ppx_deriving_popper via OPAM brings in both the ppx and the testing library. > opam install ppx_deriving_popper Similarly, if you're using the ppx, adding a preprocessor dependency on ppx_deriving_popper includes the runtime library popper as well. Currently, using the [@@deriving ... popper] attribute also requires dependencies for deriving show and ord for your data types. Below is an example dune file for defining a test. It assumes a file run.ml : (test (name run) (preprocess (pps ppx_deriving.show ppx_deriving.ord ppx_deriving_popper))) Unit tests As a first example, here is a simple unit-test verifying that the function List.rev behaves as expected when applied with the list [1; 2; 3] : open Popper let () = check @@ fun () -> equal Comparator.(list int) (List.rev [ 1; 2; 3 ]) [ 3; 2; 1 ] When run with dune runtest , it produces the following output: The function check is for running a single (anonymous) test. Its signature is: val check : ?\u2060config:Config.t -> (unit -> Proposition.t Sample.t) -> unit It takes a function that produces a value of type Proposition.t Sample.t and executes it. We'll discuss the Sample.t part in the next sections. The Proposition.t value is the result of the test, and evaluates to one of the following values: pass \u2014 the proposition is true , the test passes. fail \u2014 the proposition is false , the test fails. discarded \u2014 the proposition is neither true nor false , the tests is discarded. The function equal constructs a proposition stating that two values are equal according to the given Comparator.t value: val equal : ?\u2060loc:string -> 'a Comparator.t -> 'a -> 'a -> Proposition.t Sample.t A value of type a Comparator.t wraps a compare function and a pretty-printer for the type a . For convenience, the function returns in the Sample.t context. In this case we construct an int list Comparator.t value using the list combinator from the Comparator module. Let's see what happens when a test fails. Modifying the example above slightly: let () = check @@ fun () -> equal Comparator.(list int) (List.rev [ 1; 2; 3 ]) [ 2; 3; 1 ] This now yields: The reason the comparator embeds a pretty-printer is for being able able to explain why a particular proposition failed for the given arguments. Property-based tests A property-based test is one that, instead of verifying a concrete test-case, confirms that a certain property holds for a large number sampled data points. The technique was popularized by the Haskell library QuickCheck . Using property-based testing effectively is a topic of its own and is independent of the particular choice of library or language. Here is a good article with examples using F#. The school-book example for a property-based test is one that verifies that reversing a list twice gives the same list back. Using Popper , it can be expressed as follows: open Popper open Sample.Syntax let () = check @@ fun () -> let* xs = Sample.(list int) in equal Comparator.(list int) (List.rev (List.rev xs)) xs In the test, xs is a sample of list of integers. The test returns a proposition that asserts that after reversing xs twice we end up with the same list. The let* syntax defined in the Sample.Syntax module provides a convenient method for expressing this in a declarative way. When run, it produces the following output: The function check evaluates the property multiple times (300 by default), by drawing different samples and checking the resulting proposition for each of them. Note In Popper , there is no fundamental difference between unit tests and property-based tests. They are constructed and run using the same functions. To see what happens when a test fail, here is an example verifying that List.sort returns a sorted list, but where the condition does not account for lists containing duplicates: let rec is_sorted = function | x :: y :: ys -> x < y && is_sorted (y :: ys) | _ -> true let () = check @@ fun () -> let* xs = Sample.(list int) in is_true (is_sorted @@ List.sort Int.compare xs) The function is_true is used for constructing a proposition stating that the given boolean condition is true . This test fails with: The output is not very informative as all it says is that the proposition failed because the boolean condition was false . In order to actually observe the drawn sample for which the condition is_sorted did not hold, you need to add some logging. The simplest way is to use the function Sample.with_log : val with_log : string -> (Stdlib.Format.formatter -> 'a -> unit) -> 'a Sample.t -> 'a Sample.t It takes a string value for the key, a pretty-printer, and a sampler. It returns a new Sample.t value that also records the sampled values. To quickly obtain a pretty-printer for lists of integers, you may derive it using [@@deriving show] . We'll soon look at how to also derive samplers and comparators as well. For now: type int_list = int list [@@deriving show] let () = check @@ fun () -> let* xs = Sample.(with_log \"xs\" pp_int_list (list int)) in is_true (is_sorted @@ List.sort Int.compare xs) The result, when run: The log section now displays the sampled value xs for which the test failed. A property-based test such as the one above is run multiple times, a unit-test is only run once. How does check know how to distinguish between the two? The answer is that a unit test does not consume any input when generating the resulting proposition. Any property-based test must consume some data for drawing (pseudo-random) samples. A value of type a Sample.t is really a parser that reads input from a stream of numbers ( int32 values) and produces a result of type a . By varying the input stream we feed to the parser, we get different results. Note Whenever a failing sample is encountered, the check/run function attempts to find a smaller counter-example by shrinking the input stream that was used for producing the sample. Test suites The function check is convenient for quickly running individual tests, but when working with multiple tests it's best to bundle and run them together. There are three essential functions for this purpose: test for creating a test. suite for naming and grouping tests together. run for running a test (or a test suite). Their signatures are: val test : ?\u2060config:Config.t -> (unit -> Proposition.t Sample.t) -> Test.t val suite : (string * Test.t) list -> Test.t val run : ?\u2060config:Config.t -> Test.t -> unit Here's how you can combine the tests from above in a suite, and run it: let test_rev = test @@ fun () -> equal Comparator.(list int) (List.rev [ 1; 2; 3 ]) [ 3; 2; 1 ] let test_rev_twice = test @@ fun () -> let* xs = Sample.(list int) in equal Comparator.(list int) (List.rev (List.rev xs)) xs let test_sort = test @@ fun () -> let* xs = Sample.(with_log \"xs\" pp_int_list (list int)) in is_true (is_sorted @@ List.sort Int.compare xs) let tests = suite [ (\"Reverse\", test_rev) ; (\"Reverse twice\", test_rev_twice) ; (\"Sort\", test_sort) ] let () = run tests Hopefully the definitions are straight-forward. There are three tests which are defined using the function test . They are packed together by the suite combinator and executed with run . This results in the output: Note that the value tests has the same type as test_rev , test_rev_twice , and test_sort , namely Test.t . That means that test suites may also be nested. For instance, as in: let rev_suite = suite [ (\"Simple list\", test_rev); (\"Reverse twice\", test_rev_twice) ] let tests = suite [ (\"Reverse\", rev_suite); (\"Sort\", test_sort) ] let () = run tests Which yields: The nesting is reflected by the output, such as Reverse -> Simple list . Note There is only one type of tests \u2014 Test.t values \u2014 and tests may be nested arbitrarily using the suite combinator. Deriving samples For property-based tests, we sample data of some type and use the values for verifying certain properties. There are two options for sampling the input data: Sample the data and define comparators manually (as done in the examples above). Derive sample and comparator functions using the ppx_deriving_popper ppx. For example, consider a simple data type, exp , for representing boolean expressions: type exp = | Lit of bool | And of exp * exp | Or of exp * exp | Not of exp Along with an evaluation function, eval , with a signature: val eval : exp -> bool What if we would like to write a test that verifies that Lit false is the identity expression for Or ? That is, for any expression e , the following proposition should evaluate to true/pass: eval e = eval (Or (Lit false, e)) How can we sample exp values? We'll cover how to do this manually in a bit but the easiest way forward is to derive it. All that is needed is adding an attribute [@@deriving .. popper] . It also requires deriving ord and show for the comparator part. type exp = | Lit of bool | And of exp * exp | Or of exp * exp | Not of exp [@@deriving show, ord, popper] At the preprocessing stage, the popper ppx generates two functions: val exp_comparator : exp Comparator.t val exp_sample : exp Sample.t Alternatively, if you only care about deriving the sample function you may skip show and ord and use sample instead of popper , i.e.: type exp = ... [@@deriving sample] Before writing the property-based test, here's (a buggy) implementation of eval : let rec eval = function | Lit b -> b | And (e1, e2) -> eval e1 && eval e2 | Or (e1, e2) -> eval e1 && eval e2 | Not b -> not @@ eval b Using the exp_sample function, the test is straight forward: let test_or = test @@ fun () -> let* e = exp_sample in is_true (eval e = eval (Or (Lit false, e))) let () = run test_or The test now fails after 5 successful samples: Again, in order to actually see the expression that was generated in order for the proposition to fail, we need to add some logging: let test_or = test @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true (eval e = eval (Or(Lit false, e))) let () = run test_or The with_log requires providing a pretty-printer. We use pp_exp which is derived by show . When running the test, you now also see the logged values in the output: Combining propositions Just like tests can be composed into test suites, propositions can also be bundled. There are two functions: val all : Proposition.t Sample.t list -> Proposition.t Sample.t val any : Proposition.t Sample.t list -> Proposition.t Sample.t They both take a list of propositions (for convenience Proposition.t Sample.t values) and collapse them into a single proposition. As the names suggest, all requires all propositions to pass, and any requires at least one to do so, in order to return a successful result. Here's an example: let test_id = test @@ fun () -> let* e = exp_sample in all [ is_true (eval e = eval (Or (Lit false, e))) ; is_true (eval e = eval (And (Lit true, e))) ] You may also use the combinators from the Proposition module , which do not return in the Sample context. Configurations As you may have noticed, the functions test , check , and run all take an optional configuration argument called config . This allows overriding some settings. Either at the level of an individual test or for all tests when passed to run . In case there are overlapping settings, the ones defined at the lowest level, i.e. the ones passed to an individual test take precedence. Here are some examples of what may be configured: num_samples \u2014 for specifying the number of samples to be drawn for property-based tests. The default value is 300. verbose \u2014 whether or not the logged values should be displayed for each sample. max_size \u2014 this is a parameter that controls the maximum size parameter for data-structures like lists. It defaults to 100. For the complete list, see the module Popper.Config . First, let's see what happens when we run a test configured with verbose . Here's a modified version of the test_or function from above: let test_or = test ~config:Config.verbose @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true (eval e = eval (Or(Lit false, e))) let () = run test_or You now see what all the drawn expression samples look like: Also changing the number of samples to be tested can be done by combining Config.t values with the Config.all combinator. For example: let test_not = let config = Config.(all [verbose; num_samples 1000]) in test ~config @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true (not (eval e) = eval (Not e)) let () = run test_not The output confirms that the number of evaluated samples is now 1000: Note If property-based tests are slow to execute, you may decrease the number of samples using Config.num_samples or decrease the max-size parameter with Config.max_size . Custom samples It is not always feasible to derive generic sample functions for the data-types you need for testing. Specifically when: The data-type is abstract. There are invariants that the samples must satisfy. In those cases you need to write your own sampler. To give an example, consider testing an module, Image , with the following signature: type color = White | Black | Transparent type t val make : width:int -> height:int -> (x:int -> y:int -> color) -> t val render : t -> string val invert : t -> t Here's an implementation: module Image = struct type color = White | Black | Transparent type t = { width : int ; height : int ; get_pixel : x:int -> y:int -> color } let make ~width ~height get_pixel = { width; height; get_pixel } let render { width; height; get_pixel } = List.init height (fun y -> List.init width (fun x -> match get_pixel ~x ~y with | White -> \"w \" | Black -> \"b \" | Transparent -> \"- \") |> String.concat \"\") |> String.concat \"\\n\" let invert { width; height; get_pixel } = let get_pixel ~x ~y = match get_pixel ~x ~y with | White -> Black | Black -> White | Transparent -> White in { width; height; get_pixel } end Now say you would like to write a test for a property that states that inverting the image twice results in the same image when rendered. However, it is not possible to derive a sample function for the abstract type Image.t . Further, even if the type had been exposed we need to constrain the width and the height parameters. Luckily, writing the sample function yourself is straight forward \u2014 it's just a matter of generating the different parameters. Here is a version where the width and height varies between 0 and 14 : let sample_img = let* width = Sample.Int.range 0 15 in let* height = Sample.Int.range 0 15 in let* lookup = Sample.fn (Sample.one_value_of [ Image.Black; Image.White; Image.Transparent ]) in let get_pixel ~x ~y = lookup (x, y) in Sample.return (Image.make ~width ~height get_pixel) And here is how to use the function for defining a test: let test_invert_twice = test @@ fun () -> let* img = sample_img in equal Comparator.string (Image.render img) (Image.render (Image.invert (Image.invert img))) let suite = suite [ (\"Invert twice\", test_invert_twice) ] let () = run suite Running the test reveals a bug: The test failed after the first sample, and 13 successful shrink-steps were performed. Note An important feature of Popper is that shrinking is embedded . It means that when a failing sample is encountered, and an attempt is made to shrink it, the invariants used for constructing the sample are always respected! In the example above \u2014 with the Image.t sample \u2014 shrinking would never cause, say, the height to be negative. In the how it works section, you can read more about show sampling and shrinking really work.","title":"Getting started"},{"location":"getting_started/#getting-started","text":"In the following sections we'll look at how to get started using Popper for writing and running tests. Popper consists of two parts: A library popper \u2014 containing functions for building and executing tests. A library ppx_deriving_popper \u2014 for deriving functions for sampling and comparing test data for custom data-types.","title":"Getting started"},{"location":"getting_started/#installation","text":"Installing ppx_deriving_popper via OPAM brings in both the ppx and the testing library. > opam install ppx_deriving_popper Similarly, if you're using the ppx, adding a preprocessor dependency on ppx_deriving_popper includes the runtime library popper as well. Currently, using the [@@deriving ... popper] attribute also requires dependencies for deriving show and ord for your data types. Below is an example dune file for defining a test. It assumes a file run.ml : (test (name run) (preprocess (pps ppx_deriving.show ppx_deriving.ord ppx_deriving_popper)))","title":"Installation"},{"location":"getting_started/#unit-tests","text":"As a first example, here is a simple unit-test verifying that the function List.rev behaves as expected when applied with the list [1; 2; 3] : open Popper let () = check @@ fun () -> equal Comparator.(list int) (List.rev [ 1; 2; 3 ]) [ 3; 2; 1 ] When run with dune runtest , it produces the following output: The function check is for running a single (anonymous) test. Its signature is: val check : ?\u2060config:Config.t -> (unit -> Proposition.t Sample.t) -> unit It takes a function that produces a value of type Proposition.t Sample.t and executes it. We'll discuss the Sample.t part in the next sections. The Proposition.t value is the result of the test, and evaluates to one of the following values: pass \u2014 the proposition is true , the test passes. fail \u2014 the proposition is false , the test fails. discarded \u2014 the proposition is neither true nor false , the tests is discarded. The function equal constructs a proposition stating that two values are equal according to the given Comparator.t value: val equal : ?\u2060loc:string -> 'a Comparator.t -> 'a -> 'a -> Proposition.t Sample.t A value of type a Comparator.t wraps a compare function and a pretty-printer for the type a . For convenience, the function returns in the Sample.t context. In this case we construct an int list Comparator.t value using the list combinator from the Comparator module. Let's see what happens when a test fails. Modifying the example above slightly: let () = check @@ fun () -> equal Comparator.(list int) (List.rev [ 1; 2; 3 ]) [ 2; 3; 1 ] This now yields: The reason the comparator embeds a pretty-printer is for being able able to explain why a particular proposition failed for the given arguments.","title":"Unit tests"},{"location":"getting_started/#property-based-tests","text":"A property-based test is one that, instead of verifying a concrete test-case, confirms that a certain property holds for a large number sampled data points. The technique was popularized by the Haskell library QuickCheck . Using property-based testing effectively is a topic of its own and is independent of the particular choice of library or language. Here is a good article with examples using F#. The school-book example for a property-based test is one that verifies that reversing a list twice gives the same list back. Using Popper , it can be expressed as follows: open Popper open Sample.Syntax let () = check @@ fun () -> let* xs = Sample.(list int) in equal Comparator.(list int) (List.rev (List.rev xs)) xs In the test, xs is a sample of list of integers. The test returns a proposition that asserts that after reversing xs twice we end up with the same list. The let* syntax defined in the Sample.Syntax module provides a convenient method for expressing this in a declarative way. When run, it produces the following output: The function check evaluates the property multiple times (300 by default), by drawing different samples and checking the resulting proposition for each of them. Note In Popper , there is no fundamental difference between unit tests and property-based tests. They are constructed and run using the same functions. To see what happens when a test fail, here is an example verifying that List.sort returns a sorted list, but where the condition does not account for lists containing duplicates: let rec is_sorted = function | x :: y :: ys -> x < y && is_sorted (y :: ys) | _ -> true let () = check @@ fun () -> let* xs = Sample.(list int) in is_true (is_sorted @@ List.sort Int.compare xs) The function is_true is used for constructing a proposition stating that the given boolean condition is true . This test fails with: The output is not very informative as all it says is that the proposition failed because the boolean condition was false . In order to actually observe the drawn sample for which the condition is_sorted did not hold, you need to add some logging. The simplest way is to use the function Sample.with_log : val with_log : string -> (Stdlib.Format.formatter -> 'a -> unit) -> 'a Sample.t -> 'a Sample.t It takes a string value for the key, a pretty-printer, and a sampler. It returns a new Sample.t value that also records the sampled values. To quickly obtain a pretty-printer for lists of integers, you may derive it using [@@deriving show] . We'll soon look at how to also derive samplers and comparators as well. For now: type int_list = int list [@@deriving show] let () = check @@ fun () -> let* xs = Sample.(with_log \"xs\" pp_int_list (list int)) in is_true (is_sorted @@ List.sort Int.compare xs) The result, when run: The log section now displays the sampled value xs for which the test failed. A property-based test such as the one above is run multiple times, a unit-test is only run once. How does check know how to distinguish between the two? The answer is that a unit test does not consume any input when generating the resulting proposition. Any property-based test must consume some data for drawing (pseudo-random) samples. A value of type a Sample.t is really a parser that reads input from a stream of numbers ( int32 values) and produces a result of type a . By varying the input stream we feed to the parser, we get different results. Note Whenever a failing sample is encountered, the check/run function attempts to find a smaller counter-example by shrinking the input stream that was used for producing the sample.","title":"Property-based tests"},{"location":"getting_started/#test-suites","text":"The function check is convenient for quickly running individual tests, but when working with multiple tests it's best to bundle and run them together. There are three essential functions for this purpose: test for creating a test. suite for naming and grouping tests together. run for running a test (or a test suite). Their signatures are: val test : ?\u2060config:Config.t -> (unit -> Proposition.t Sample.t) -> Test.t val suite : (string * Test.t) list -> Test.t val run : ?\u2060config:Config.t -> Test.t -> unit Here's how you can combine the tests from above in a suite, and run it: let test_rev = test @@ fun () -> equal Comparator.(list int) (List.rev [ 1; 2; 3 ]) [ 3; 2; 1 ] let test_rev_twice = test @@ fun () -> let* xs = Sample.(list int) in equal Comparator.(list int) (List.rev (List.rev xs)) xs let test_sort = test @@ fun () -> let* xs = Sample.(with_log \"xs\" pp_int_list (list int)) in is_true (is_sorted @@ List.sort Int.compare xs) let tests = suite [ (\"Reverse\", test_rev) ; (\"Reverse twice\", test_rev_twice) ; (\"Sort\", test_sort) ] let () = run tests Hopefully the definitions are straight-forward. There are three tests which are defined using the function test . They are packed together by the suite combinator and executed with run . This results in the output: Note that the value tests has the same type as test_rev , test_rev_twice , and test_sort , namely Test.t . That means that test suites may also be nested. For instance, as in: let rev_suite = suite [ (\"Simple list\", test_rev); (\"Reverse twice\", test_rev_twice) ] let tests = suite [ (\"Reverse\", rev_suite); (\"Sort\", test_sort) ] let () = run tests Which yields: The nesting is reflected by the output, such as Reverse -> Simple list . Note There is only one type of tests \u2014 Test.t values \u2014 and tests may be nested arbitrarily using the suite combinator.","title":"Test suites"},{"location":"getting_started/#deriving-samples","text":"For property-based tests, we sample data of some type and use the values for verifying certain properties. There are two options for sampling the input data: Sample the data and define comparators manually (as done in the examples above). Derive sample and comparator functions using the ppx_deriving_popper ppx. For example, consider a simple data type, exp , for representing boolean expressions: type exp = | Lit of bool | And of exp * exp | Or of exp * exp | Not of exp Along with an evaluation function, eval , with a signature: val eval : exp -> bool What if we would like to write a test that verifies that Lit false is the identity expression for Or ? That is, for any expression e , the following proposition should evaluate to true/pass: eval e = eval (Or (Lit false, e)) How can we sample exp values? We'll cover how to do this manually in a bit but the easiest way forward is to derive it. All that is needed is adding an attribute [@@deriving .. popper] . It also requires deriving ord and show for the comparator part. type exp = | Lit of bool | And of exp * exp | Or of exp * exp | Not of exp [@@deriving show, ord, popper] At the preprocessing stage, the popper ppx generates two functions: val exp_comparator : exp Comparator.t val exp_sample : exp Sample.t Alternatively, if you only care about deriving the sample function you may skip show and ord and use sample instead of popper , i.e.: type exp = ... [@@deriving sample] Before writing the property-based test, here's (a buggy) implementation of eval : let rec eval = function | Lit b -> b | And (e1, e2) -> eval e1 && eval e2 | Or (e1, e2) -> eval e1 && eval e2 | Not b -> not @@ eval b Using the exp_sample function, the test is straight forward: let test_or = test @@ fun () -> let* e = exp_sample in is_true (eval e = eval (Or (Lit false, e))) let () = run test_or The test now fails after 5 successful samples: Again, in order to actually see the expression that was generated in order for the proposition to fail, we need to add some logging: let test_or = test @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true (eval e = eval (Or(Lit false, e))) let () = run test_or The with_log requires providing a pretty-printer. We use pp_exp which is derived by show . When running the test, you now also see the logged values in the output:","title":"Deriving samples"},{"location":"getting_started/#combining-propositions","text":"Just like tests can be composed into test suites, propositions can also be bundled. There are two functions: val all : Proposition.t Sample.t list -> Proposition.t Sample.t val any : Proposition.t Sample.t list -> Proposition.t Sample.t They both take a list of propositions (for convenience Proposition.t Sample.t values) and collapse them into a single proposition. As the names suggest, all requires all propositions to pass, and any requires at least one to do so, in order to return a successful result. Here's an example: let test_id = test @@ fun () -> let* e = exp_sample in all [ is_true (eval e = eval (Or (Lit false, e))) ; is_true (eval e = eval (And (Lit true, e))) ] You may also use the combinators from the Proposition module , which do not return in the Sample context.","title":"Combining propositions"},{"location":"getting_started/#configurations","text":"As you may have noticed, the functions test , check , and run all take an optional configuration argument called config . This allows overriding some settings. Either at the level of an individual test or for all tests when passed to run . In case there are overlapping settings, the ones defined at the lowest level, i.e. the ones passed to an individual test take precedence. Here are some examples of what may be configured: num_samples \u2014 for specifying the number of samples to be drawn for property-based tests. The default value is 300. verbose \u2014 whether or not the logged values should be displayed for each sample. max_size \u2014 this is a parameter that controls the maximum size parameter for data-structures like lists. It defaults to 100. For the complete list, see the module Popper.Config . First, let's see what happens when we run a test configured with verbose . Here's a modified version of the test_or function from above: let test_or = test ~config:Config.verbose @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true (eval e = eval (Or(Lit false, e))) let () = run test_or You now see what all the drawn expression samples look like: Also changing the number of samples to be tested can be done by combining Config.t values with the Config.all combinator. For example: let test_not = let config = Config.(all [verbose; num_samples 1000]) in test ~config @@ fun () -> let* e = Sample.with_log \"e\" pp_exp exp_sample in is_true (not (eval e) = eval (Not e)) let () = run test_not The output confirms that the number of evaluated samples is now 1000: Note If property-based tests are slow to execute, you may decrease the number of samples using Config.num_samples or decrease the max-size parameter with Config.max_size .","title":"Configurations"},{"location":"getting_started/#custom-samples","text":"It is not always feasible to derive generic sample functions for the data-types you need for testing. Specifically when: The data-type is abstract. There are invariants that the samples must satisfy. In those cases you need to write your own sampler. To give an example, consider testing an module, Image , with the following signature: type color = White | Black | Transparent type t val make : width:int -> height:int -> (x:int -> y:int -> color) -> t val render : t -> string val invert : t -> t Here's an implementation: module Image = struct type color = White | Black | Transparent type t = { width : int ; height : int ; get_pixel : x:int -> y:int -> color } let make ~width ~height get_pixel = { width; height; get_pixel } let render { width; height; get_pixel } = List.init height (fun y -> List.init width (fun x -> match get_pixel ~x ~y with | White -> \"w \" | Black -> \"b \" | Transparent -> \"- \") |> String.concat \"\") |> String.concat \"\\n\" let invert { width; height; get_pixel } = let get_pixel ~x ~y = match get_pixel ~x ~y with | White -> Black | Black -> White | Transparent -> White in { width; height; get_pixel } end Now say you would like to write a test for a property that states that inverting the image twice results in the same image when rendered. However, it is not possible to derive a sample function for the abstract type Image.t . Further, even if the type had been exposed we need to constrain the width and the height parameters. Luckily, writing the sample function yourself is straight forward \u2014 it's just a matter of generating the different parameters. Here is a version where the width and height varies between 0 and 14 : let sample_img = let* width = Sample.Int.range 0 15 in let* height = Sample.Int.range 0 15 in let* lookup = Sample.fn (Sample.one_value_of [ Image.Black; Image.White; Image.Transparent ]) in let get_pixel ~x ~y = lookup (x, y) in Sample.return (Image.make ~width ~height get_pixel) And here is how to use the function for defining a test: let test_invert_twice = test @@ fun () -> let* img = sample_img in equal Comparator.string (Image.render img) (Image.render (Image.invert (Image.invert img))) let suite = suite [ (\"Invert twice\", test_invert_twice) ] let () = run suite Running the test reveals a bug: The test failed after the first sample, and 13 successful shrink-steps were performed. Note An important feature of Popper is that shrinking is embedded . It means that when a failing sample is encountered, and an attempt is made to shrink it, the invariants used for constructing the sample are always respected! In the example above \u2014 with the Image.t sample \u2014 shrinking would never cause, say, the height to be negative. In the how it works section, you can read more about show sampling and shrinking really work.","title":"Custom samples"},{"location":"how_it_works/","text":"How it works Popper is designed to facilitate property-based testing, where regular unit tests are just special cases. It's inspired by a technique introduced by the Python library Hypothesis . The fundamental difference between libraries based on the original property-based testing framework, QuickCheck , has to do with how sample generation and shrinking work. In QuickCheck-based libraries, there are two orthogonal concepts: Generators \u2014 for generating arbitrary test data (samples). Shrinkers \u2014 for simplifying values that results in failing tests. For any custom data-type you wish to sample, you need to provide a generator as well as a shrinker (or no shrinking is applied). Further, any invariant \u2014 with respect to how samples are generated \u2014 must also be reflected in the shrinker. In Popper and Hypothesis , shrinking is generic and never violates any invariants embedded in the generators. This eliminates the hassle of defining shrinkers and keeping them in synch. The downside is that it may be less efficient and doesn't always produce optimally shrunken results. Sampling and shrinking A sampler , in Popper, is a value of some type a Sample.t and corresponds to a generator in QuickCheck . When an a Sample.t value is run, it consumes input from a sequence of int32 values. Each number is used for guiding some decision or for parsing a primitive value. Here's a high-level depiction of what is involved in running a test: All the numbers consumed from the input stream are recorded and tagged in order to provide some information about the different sub-segments of the input. In fact, the consumed data is arranged in a tree structure. This makes it easier for the shrinker to modify the tree by either removing sub-branches or shrinking the leaves. The tree can be collapsed into a flat structure and converted back to a new input-stream, which in turn is fed to the sampler. An example To look at a concrete example, below is dummy-test for illustrating how sampling and shrinking really works. The code introduces a new data-type, contact , for which a sample function is derived. The function test samples a contact value and returns a proposition that fails for any sample produced by the Mail constructor. The derived sample function contact_sample is enhanced with logging and also returns the consumed input, via the function Sample.with_consumed . Additionally the sampler is resized* to 10 so that small \u2014 but not too small values \u2014 initially: open Popper open Sample.Syntax type contact = | Email of string | Mail of { street : string ; number : int option ; zip : string } [@@deriving show, ord, popper] let test () = let* contact, consumed = contract_sample |> Sample.resize 10 |> Sample.with_log \"contact\" pp_contact |> Sample.with_consumed in Format.printf \"%a@.%a@.\" Consumed.pp consumed pp_contact contact; match contact with | Email _ -> pass | Mail _ -> fail \"Expected email\" let () = check test Each sampled contact value and consumed input pair is also printed. When run, we can see how the samples are produced and what the consumed data looks like. That is the the data in the input-stream fed to the sampler. The first consumed input and corresponding contact pair is: 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 875735887 2 name[street]-1,list-2,sub-list-3,name[element]-5,char-6 1313326574 3 name[street]-1,list-2,sub-list-3,sub-list-7,choice-8 1489071124 4 name[street]-1,list-2,sub-list-3,sub-list-7,name[element]-9,char-10 146106767 5 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-11,choice-12 620372157 6 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-13,choice-14 1449571827 7 name[street]-1,list-2,sub-list-3,sub-list-15,choice-16 398247927 8 name[number]-17 154391388 9 name[zip]-18,list-19,sub-list-20,choice-21 877744873 10 name[zip]-18,list-19,sub-list-20,name[element]-22,char-23 113482031 11 name[zip]-18,list-19,sub-list-20,sub-list-24,choice-25 2102918577 12 name[zip]-18,list-19,sub-list-20,sub-list-24,name[element]-26,char-27 352979668 13 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-28,choice-29 1423603695 14 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-30,choice-31 2122464862 15 name[zip]-18,list-19,sub-list-20,sub-list-32,choice-33 279715071 Run.Mail {street = \"Ni\"; number = None; zip = \"wV\"} This happened to be a Mail contact why the proposition returned failed. Now, shrinking kicks in, in order to find a smaller input sequence for which the test still fails. The algorithm for shrinking takes into account the tagged information. It's a search procedure where at at each step an attempt to either Decrease some value from the input sequence. Remove some blocks of values. Decreasing could mean changing the input that resulted in character N to be a and removing blocks might result in removing some elements from a list. When it comes to removing, the tagging of the input is important as it gives hints to where candidates for removing feasible subsections are encountered. Randomly removing data is likely to drastically alter the resulting sample. For every shrink step, the sample function is run again in order to verify that the sampled data still yields a failed proposition. The algorithm never looks at the sampled values themselves. It only notices whether or not shrinking was successful. The key to shrinking is that sampler are designed such that a shorter and smaller input implies smaller sampled values. Since we're printing each invocation of the test function, we can observe each shrink attempt. Here are a few of the intermediate ones: 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 875735887 2 name[street]-1,list-2,sub-list-3,name[element]-5,char-6 1313326574 3 name[street]-1,list-2,sub-list-3,sub-list-7,choice-8 1489071124 4 name[street]-1,list-2,sub-list-3,sub-list-7,name[element]-9,char-10 0 5 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-11,choice-12 398247927 6 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-13,choice-14 77195694 7 name[street]-1,list-2,sub-list-3,sub-list-15,choice-16 877744873 8 name[number]-17 0 9 name[zip]-18,list-19,sub-list-20,choice-21 2102918577 10 name[zip]-18,list-19,sub-list-20,name[element]-22,char-23 352979668 11 name[zip]-18,list-19,sub-list-20,sub-list-24,choice-25 1423603695 12 name[zip]-18,list-19,sub-list-20,sub-list-24,name[element]-26,char-27 2122464862 13 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-28,choice-29 0 14 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-30,choice-31 0 15 name[zip]-18,list-19,sub-list-20,sub-list-32,choice-33 0 Run.Mail {street = \"N0\"; number = None; zip = \"00\"} ... 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 0 2 name[number]-5 0 3 name[zip]-6,list-7,sub-list-8,choice-9 2102918577 4 name[zip]-6,list-7,sub-list-8,name[element]-10,char-11 0 5 name[zip]-6,list-7,sub-list-8,sub-list-12,choice-13 2122464862 6 name[zip]-6,list-7,sub-list-8,sub-list-12,name[element]-14,char-15 0 7 name[zip]-6,list-7,sub-list-8,sub-list-12,sub-list-16,choice-17 0 8 name[zip]-6,list-7,sub-list-8,sub-list-12,sub-list-18,choice-19 0 9 name[zip]-6,list-7,sub-list-8,sub-list-20,choice-21 352979668 ... Run.Mail {street = \"\"; number = None; zip = \"00\"} 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 0 2 name[number]-5 0 3 name[zip]-6,list-7,sub-list-8,choice-9 0 (Run.Email \"0\") ... 0 0 1 name[x0]-1,list-2,sub-list-3,choice-4 875735887 2 name[x0]-1,list-2,sub-list-3,name[element]-5,char-6 1313326574 3 name[x0]-1,list-2,sub-list-3,sub-list-7,choice-8 0 4 name[x0]-1,list-2,sub-list-3,sub-list-9,choice-10 77195694 Run.Mail {street = \"N\"; number = None; zip = \"\"} As seen, sometimes the shrink step fails and results in a valid test. Eventually, in this case, the input is shrunken down to the following sequence: 0 1303638795 1 name[street]-1,list-2,sub-list-3,choice-4 0 2 name[number]-5 0 3 name[zip]-6,list-7,sub-list-8,choice-9 0 Run.Mail {street = \"\"; number = None; zip = \"\"} And the final counter-example is displayed:","title":"How it works"},{"location":"how_it_works/#how-it-works","text":"Popper is designed to facilitate property-based testing, where regular unit tests are just special cases. It's inspired by a technique introduced by the Python library Hypothesis . The fundamental difference between libraries based on the original property-based testing framework, QuickCheck , has to do with how sample generation and shrinking work. In QuickCheck-based libraries, there are two orthogonal concepts: Generators \u2014 for generating arbitrary test data (samples). Shrinkers \u2014 for simplifying values that results in failing tests. For any custom data-type you wish to sample, you need to provide a generator as well as a shrinker (or no shrinking is applied). Further, any invariant \u2014 with respect to how samples are generated \u2014 must also be reflected in the shrinker. In Popper and Hypothesis , shrinking is generic and never violates any invariants embedded in the generators. This eliminates the hassle of defining shrinkers and keeping them in synch. The downside is that it may be less efficient and doesn't always produce optimally shrunken results.","title":"How it works"},{"location":"how_it_works/#sampling-and-shrinking","text":"A sampler , in Popper, is a value of some type a Sample.t and corresponds to a generator in QuickCheck . When an a Sample.t value is run, it consumes input from a sequence of int32 values. Each number is used for guiding some decision or for parsing a primitive value. Here's a high-level depiction of what is involved in running a test: All the numbers consumed from the input stream are recorded and tagged in order to provide some information about the different sub-segments of the input. In fact, the consumed data is arranged in a tree structure. This makes it easier for the shrinker to modify the tree by either removing sub-branches or shrinking the leaves. The tree can be collapsed into a flat structure and converted back to a new input-stream, which in turn is fed to the sampler.","title":"Sampling and shrinking"},{"location":"how_it_works/#an-example","text":"To look at a concrete example, below is dummy-test for illustrating how sampling and shrinking really works. The code introduces a new data-type, contact , for which a sample function is derived. The function test samples a contact value and returns a proposition that fails for any sample produced by the Mail constructor. The derived sample function contact_sample is enhanced with logging and also returns the consumed input, via the function Sample.with_consumed . Additionally the sampler is resized* to 10 so that small \u2014 but not too small values \u2014 initially: open Popper open Sample.Syntax type contact = | Email of string | Mail of { street : string ; number : int option ; zip : string } [@@deriving show, ord, popper] let test () = let* contact, consumed = contract_sample |> Sample.resize 10 |> Sample.with_log \"contact\" pp_contact |> Sample.with_consumed in Format.printf \"%a@.%a@.\" Consumed.pp consumed pp_contact contact; match contact with | Email _ -> pass | Mail _ -> fail \"Expected email\" let () = check test Each sampled contact value and consumed input pair is also printed. When run, we can see how the samples are produced and what the consumed data looks like. That is the the data in the input-stream fed to the sampler. The first consumed input and corresponding contact pair is: 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 875735887 2 name[street]-1,list-2,sub-list-3,name[element]-5,char-6 1313326574 3 name[street]-1,list-2,sub-list-3,sub-list-7,choice-8 1489071124 4 name[street]-1,list-2,sub-list-3,sub-list-7,name[element]-9,char-10 146106767 5 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-11,choice-12 620372157 6 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-13,choice-14 1449571827 7 name[street]-1,list-2,sub-list-3,sub-list-15,choice-16 398247927 8 name[number]-17 154391388 9 name[zip]-18,list-19,sub-list-20,choice-21 877744873 10 name[zip]-18,list-19,sub-list-20,name[element]-22,char-23 113482031 11 name[zip]-18,list-19,sub-list-20,sub-list-24,choice-25 2102918577 12 name[zip]-18,list-19,sub-list-20,sub-list-24,name[element]-26,char-27 352979668 13 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-28,choice-29 1423603695 14 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-30,choice-31 2122464862 15 name[zip]-18,list-19,sub-list-20,sub-list-32,choice-33 279715071 Run.Mail {street = \"Ni\"; number = None; zip = \"wV\"} This happened to be a Mail contact why the proposition returned failed. Now, shrinking kicks in, in order to find a smaller input sequence for which the test still fails. The algorithm for shrinking takes into account the tagged information. It's a search procedure where at at each step an attempt to either Decrease some value from the input sequence. Remove some blocks of values. Decreasing could mean changing the input that resulted in character N to be a and removing blocks might result in removing some elements from a list. When it comes to removing, the tagging of the input is important as it gives hints to where candidates for removing feasible subsections are encountered. Randomly removing data is likely to drastically alter the resulting sample. For every shrink step, the sample function is run again in order to verify that the sampled data still yields a failed proposition. The algorithm never looks at the sampled values themselves. It only notices whether or not shrinking was successful. The key to shrinking is that sampler are designed such that a shorter and smaller input implies smaller sampled values. Since we're printing each invocation of the test function, we can observe each shrink attempt. Here are a few of the intermediate ones: 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 875735887 2 name[street]-1,list-2,sub-list-3,name[element]-5,char-6 1313326574 3 name[street]-1,list-2,sub-list-3,sub-list-7,choice-8 1489071124 4 name[street]-1,list-2,sub-list-3,sub-list-7,name[element]-9,char-10 0 5 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-11,choice-12 398247927 6 name[street]-1,list-2,sub-list-3,sub-list-7,sub-list-13,choice-14 77195694 7 name[street]-1,list-2,sub-list-3,sub-list-15,choice-16 877744873 8 name[number]-17 0 9 name[zip]-18,list-19,sub-list-20,choice-21 2102918577 10 name[zip]-18,list-19,sub-list-20,name[element]-22,char-23 352979668 11 name[zip]-18,list-19,sub-list-20,sub-list-24,choice-25 1423603695 12 name[zip]-18,list-19,sub-list-20,sub-list-24,name[element]-26,char-27 2122464862 13 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-28,choice-29 0 14 name[zip]-18,list-19,sub-list-20,sub-list-24,sub-list-30,choice-31 0 15 name[zip]-18,list-19,sub-list-20,sub-list-32,choice-33 0 Run.Mail {street = \"N0\"; number = None; zip = \"00\"} ... 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 0 2 name[number]-5 0 3 name[zip]-6,list-7,sub-list-8,choice-9 2102918577 4 name[zip]-6,list-7,sub-list-8,name[element]-10,char-11 0 5 name[zip]-6,list-7,sub-list-8,sub-list-12,choice-13 2122464862 6 name[zip]-6,list-7,sub-list-8,sub-list-12,name[element]-14,char-15 0 7 name[zip]-6,list-7,sub-list-8,sub-list-12,sub-list-16,choice-17 0 8 name[zip]-6,list-7,sub-list-8,sub-list-12,sub-list-18,choice-19 0 9 name[zip]-6,list-7,sub-list-8,sub-list-20,choice-21 352979668 ... Run.Mail {street = \"\"; number = None; zip = \"00\"} 0 1303638800 1 name[street]-1,list-2,sub-list-3,choice-4 0 2 name[number]-5 0 3 name[zip]-6,list-7,sub-list-8,choice-9 0 (Run.Email \"0\") ... 0 0 1 name[x0]-1,list-2,sub-list-3,choice-4 875735887 2 name[x0]-1,list-2,sub-list-3,name[element]-5,char-6 1313326574 3 name[x0]-1,list-2,sub-list-3,sub-list-7,choice-8 0 4 name[x0]-1,list-2,sub-list-3,sub-list-9,choice-10 77195694 Run.Mail {street = \"N\"; number = None; zip = \"\"} As seen, sometimes the shrink step fails and results in a valid test. Eventually, in this case, the input is shrunken down to the following sequence: 0 1303638795 1 name[street]-1,list-2,sub-list-3,choice-4 0 2 name[number]-5 0 3 name[zip]-6,list-7,sub-list-8,choice-9 0 Run.Mail {street = \"\"; number = None; zip = \"\"} And the final counter-example is displayed:","title":"An example"}]}